<?php

namespace Chartwell\Modules\WorksCalendarBundle\Entity;

use Doctrine\ORM\AbstractQuery;
use Doctrine\ORM\EntityRepository;

use Chartwell\CoreBundle\Toolkit\Lists;

/**
 * WorkRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class WorkRepository extends EntityRepository
{

    /**
     * @param $engineerId
     * @param $slotsArr
     * @param $date
     * @return int
     */
    public function existsingWorksCount($engineerId, $slotsArr, $date)
    {
        $qb = $this->_em->createQueryBuilder();

        $issetWorks = $this->createQueryBuilder('w')
            ->select(array('COUNT(s.id) as cnt'))
            ->join('w.slots', 's')
            ->where($qb->expr()->eq('w.engineer', $engineerId))
            ->andWhere(
                $qb->expr()->andX(
                    $qb->expr()->lte('w.fromDate', $qb->expr()->literal($date->format('Y-m-d H:i:s'))),
                    $qb->expr()->gte('w.toDate', $qb->expr()->literal($date->format('Y-m-d H:i:s')))
                )
            )
            ->andWhere($qb->expr()->in('s.label', $slotsArr))
            ->getQuery()
            ->getResult(AbstractQuery::HYDRATE_ARRAY);

        return (int)$issetWorks[0]['cnt'];
    }

    /**
     * @param $engineers
     * @param $slots
     * @param $division
     * @param $startDate
     * @param bool $skipIncompleted
     * @return array
     */
    public function prepareWorksArr($engineers, $slots, $division, \DateTime $startDate, \DateTime $endDate, $isCompleted = null)
    {
        $worksArr = array();
        $usedWorks = array();
        $keys = array();
        for ($i = 1; $i <= 21; $i++) {
            $keys[$i] = null;
        }
        $diff = $endDate->diff($startDate);

        $days = abs($diff->days) + 1;

        foreach ($slots as $slot) {
            for ($i = 1; $i <= $days; $i++) {
                $useDate = clone $startDate;
                $useDate->add(new \DateInterval('P' . ($i - 1) . 'D'));
                foreach ($engineers as $engineer) {
                    if (!isset($worksArr[$engineer->getId()])) {
                        $worksArr[$engineer->getId()] = $keys;
                    }
                    $workCollection = $engineer->getWorks()->filter(function ($entry) use ($slot, $useDate, $division, $isCompleted) {
                        $condition = ($entry->getDivision()->getId() === $division->getId() || $entry->getEngineer()->getWorkCalendarDivision()->getId() === $division->getId()) && $entry->hasSlot($slot) && $entry->getFromDate()->getTimestamp() <= $useDate->getTimestamp() && $entry->getToDate()->getTimestamp() >= $useDate->getTimestamp();
                        if ($isCompleted !== null) {
                            return $condition && $entry->isCompleted();
                        } else {
                            return $condition;
                        }
                    });

                    if ($workCollection->count() > 0 && !in_array($workCollection->first()->getId(), $usedWorks)) {
                        $work = $workCollection->first();
                        $position = $work->getStartPosition($useDate);
                        $worksArr[$engineer->getId()][$position] = array(
                            $work,
                            $work->getColumns($useDate)
                        );
                        $usedWorks[] = $work->getId();
                    }
                }
            }
        }

        return $worksArr;
    }

    /**
     * @param $startDate
     * @return array
     */
    public function prepareDays($startDate)
    {
        $days = array();

        for ($i = 0; $i < 7; $i++) {
            $d = clone $startDate;
            $d->add(new \DateInterval('P' . $i . 'D'));
            $days[] = $d->format('D jS');
        }

        return $days;
    }

    public function getStartWorksDate(){
        $result = $this->createQueryBuilder('w')
            ->select('MIN(w.fromDate)')
            ->setMaxResults(1)
            ->getQuery()
            ->getOneOrNullResult(\Doctrine\ORM\AbstractQuery::HYDRATE_SINGLE_SCALAR);
        if($result){
            $date = new \DateTime($result);
        } else {
            $date = new \DateTime();
        }
        $date
            ->setISODate($date->format('Y'), $date->format('W'), 1)
            ->setTime(0, 0, 0);

        return $date;
    }

}
